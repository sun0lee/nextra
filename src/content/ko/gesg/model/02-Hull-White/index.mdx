---
title: "Hull-White 모델"
---

# Hull-White 1 Factor 모델

## 1. TVOG와 Hull-White 모델 

> 	보험/연금 부채 평가에서 확정되지 않은 미래 금리를 어떻게 다룰 것인가? 

K-ICS에서는 보험사의 지급여력 측정을 위해 부채의 경제적 가치를 산출하며, 이때 부채의 옵션(예: 금리보증)이나 금리변동 위험에 노출된 구조적 특징을 반영하기 위해서 확률론적 시나리오 기반 평가(stochastic valuation)로 금리 변동에 따라 영향을 받는 현금흐름 효과를 반영하여 측정한다. 

K-ICS에서는 확률론적 시나리오를 생성하기 위해 Hull-White 1 Factor 모형을 사용하여 미래 1000개의 미래 금리 경로를 생성하고, 이를 바탕으로 각 시나리오별 부채의 현재가치를 산출한다. 이 시나리오의 변동성을 반영하여 산출되는 항목이 바로 TVOG(Time Value of Options and Guarantees)이다.

즉, Hull-White 모형은 보험부채에 내재된 옵션성 가치의 측정 도구로, 이 모형을 통해 금리보증(GMDB, GMWB 등), 부리형 상품, 해지 옵션 등의 가치를 경제적으로 평가할 수 있다.



<Accordion activeIndex={[0]}>
<AccordionTab header="[IFRS 17] TVOG 관련 규정 ">
<TabView>
<TabPanel header="13 ">
      13. 문단 11\~12를 적용한 후에는 주계약인 보험계약의 나머지 모든 구성요소에 이 기준서를 적용한다. 이하 이 기준서에서 내재파생상품에 관한 모든 사항은 주계약인 보험계약에서 분리되지 않은 파생상품을 말하며 투자요소에 대한 설명에서 투자요소에 관한 모든 사항은 주계약인 보험계약에서 분리되지 않은 투자요소를 말한다(문단 B31\~B32에서 설명하는 사항은 제외).
</TabPanel>
<TabPanel header="B48 ">
      - B48. 자산의 운용성과에 기반하여 변동하는 현금흐름과 기타의 현금흐름 간에 유의적인 상호의존성이 있을 경우 복제포트폴리오 이외의 기법(예: 확률모형기법)을 적용하는 것이 보다 견고하거나 용이할 수 있다. 특정 상황에서 관측 가능한 시장변수와의 일관성을 유지하기 위한 목적을 가장 잘 충족할 수 있는 기법을 결정하기 위해서 판단이 요구된다. 특히, 보험계약에 옵션과 보증이 포함되어 있고 그러한 옵션과 보증에 대한 관측 가능한 시장가격이 있다면 관측 가능한 시장가격과 일관되도록 측정하는 측정기법이 사용되어야 한다.

</TabPanel>
<TabPanel header="B65 ">
      - B65.보험계약의 경계 내에 있는 현금흐름은 계약의 이행과 직접적으로 관련이 있는 현금흐름으로서, 기업이 금액 또는 시기에 대해 재량을 가지는 현금흐름을 포함한다. 계약의 경계 내에 있는 현금흐름은 다음을 포함한다.
          - $\cdots$ 
          - ⑷ 파생상품으로 인하여 보험계약자에게(또는 보험계약자를 대신해서) 지급하는 금액. 이러한 파생상품의 예로 옵션 또는 보증이 보험계약에서 분리되지 않은 경우 (문단 11(1) 참조), 그 계약에 내재된 옵션 또는 보증을 들 수 있다.

</TabPanel>
<TabPanel header="B76 ">
      - B76.변동이익을 갖는 기초항목의 성과에 따라 변동하지만, 최저수익 보증의 대상인 현금흐름은, 보증수준이 기초항목의 기대 성과보다 낮은 경우에도, 기초항목의 성과에만 근거하여 변동하지 않는다. 따라서 기업은 보증수준이 기초항목의 기대성과보다 낮은 경우에도, 보증효과에 대한 기초항목의 성과 변동성을 반영하여 할인율을 조정해야 한다.

</TabPanel>
</TabView>

</AccordionTab>
<AccordionTab header="[K-ICS] TVOG 관련 규정 ">
<TabView>
<TabPanel header="3-2. 현행추정부채">
    **나. 보험료부채 ⑹ 옵션 및 보증평가**
    - ① 현행추정부채를 산출할 때 미래 현금흐름은 보험계약에서 장래에 발생할 것으로 예상되는 옵션 및 보증을 고려하여 평가해야 한다
      - ㈀ 옵션은 계약해지, 위험보장 증액·감액 등 계약자 행동에 따른 옵션 등을 말한다.
      - ㈁ 보증은 최저보증이율, 최저사망보험금 보증, 최소적립금 보증 등을 말한다.
      - ㈂ 옵션 및 보증의 시간가치(TVOG)는 확률론적 시나리오에 의해 산출된 값에서 결정론적 시나리오에 의해 산출된 값을 차감한 금액으로 산출한다.  

</TabPanel>
<TabPanel header="5-2. 할인율 산출구조 ">
    - 나. 보험부채 평가시 적용하는 확률론적 시나리오는 조정 무위험 금리 기간구조를 기반으로 확률론적 금리모형을 통해 산출한다.  

</TabPanel>
<TabPanel header="5-3. 원화 할인율 산출 ">
    - 다. 보험부채의 옵션 및 보증가치를 평가하기 위하여 확률론적 금리 모형을 통해 할인율을 산출한다.
      - ⑴ 보험회사는 Ⅱ.5-3.나 (조정 무위험 금리기간구조)를 기반으로 ⑶ 산출모형에서 정한 확률론적 금리 모형을 적용하여 확률론적 시나리오를 산출한다.
      - ⑵ 확률론적 시나리오는 최소 1,000개 이상으로 한다.
      - ⑶ 확률론적 시나리오를 생성하는 모형(Hull-White 1 factor 모형)은 다음과 같다.
      <GMath title ="">
      $$
      dr(t) = \alpha \cdot [ \theta(t) - r(t)]dt + \sigma \cdot dW(t)
      $$
      </GMath>
      <GCmt>
      - – 수렴속도 모수($\alpha$): 금리시나리오가 수익률 곡선에 회귀하는 속도를 결정하는 모수
      - – 변동성 모수($\sigma$): 금리의 변동성을 결정하는 모수
      - – $\theta(t)$ : 수익률곡선이 복원가능하도록 조정하는 역할을 하는 함수 (Hull-White 모형에서 이자율 곡선의 장기 평균 회귀 속도를 조절)
      - – $dW(t)$: 브라운 운동에 대한 확률 증분 (시간에 따라 변동하는 무작위한 움직임을 표현함)
      </GCmt>

</TabPanel>
</TabView>


</AccordionTab>
</Accordion>

## 2. 모델의 구성

확률론적 금리 시나리오는 단기금리의 확률적 경로를 바탕으로 생성된다. 단기금리란 특정 시점의 무위험 이자율 수준을 의미하며, 이를 확률과 시간의 함수로 모델링함으로써 전체 수익률곡선을 유도할 수 있다.

Hull-White 1 Factor 모형은 이러한 단기금리의 확률적 움직임을 수학적으로 정의한 대표적인 모델로, 다음과 같은 기본 구조를 갖는다
<GMath title ="확률미분방정식(SDE)">
$$
dr(t) = \alpha (t) \cdot [ \theta(t) - r(t)]dt + \sigma \cdot dW(t)
$$
</GMath>
<GCmt>
    - • $$\theta(t)$$ ; 목표금리, 관찰된 시장 금리곡선에 적합시켜 금리가 시장금리곡선을 중심으로 수렴하도록 함.
    - $\theta(t) = \dfrac{f_{t+1}-f_t}{\alpha_t \Delta t} + f_t + \int_0^t \sigma_u^2 \cdot e^{-2\alpha_u \cdot(t-u)}du
    = \dfrac{f_{t+1}-f_t}{\alpha_t \Delta t} + f_t + Z(t)$
    - • $$\alpha(t)$$; 회귀모수, 목표금리로 수렴하는 속도
    - • $$\sigma(t)$$; 변동성모수, 연율화된 금리의 변동성
    - • $$dW_t$$; Brownian Motion, 확률적으로 움직이는 위험 요인
</GCmt>

<GCallout severity="success" title ="Hull-White 1 Factor 모형의 특징">
	- •	금리는 시간이 지남에 따라 평균으로 회귀하려는 경향을 보인다 (mean-reversion)
	- •	금리는 무작위적인 충격(브라운 운동)에 따라 변동성을 가지며 움직인다
	- •	초기 시점의 수익률 곡선은 모델에 직접 반영되어 현실 적합성 유지한다 (No-Arbitrage)
</GCallout>


아래에서는 Hull-White one factor 모형의 개념과 수식, 스왑션 변동성 데이터를 기반으로 파라미터 추정, 시나리오 생성 및 검증 방법 등을 단계적으로 설명한다.



## 3. Parameter

시장 데이터는 연속적이지 않기 때문에 평균회귀 속도와 변동성에 대한 매개변수도 불연속적인 경우로 다룬다. 특히, 금리 시계열은 구간(단기구간, 장기구간)에 따라 성질이 다르므로 <GTooltipIcon desc="- 단기구간 : 중앙은행의 정책금리에 영향을 많이 받음. mean-reversion 속도가 빠름 / 장기구간 : 기대인플레이션 구조적 금리 수준의 영향을 받음. mean-reversion 속도가 느림"/>, 모수 역시 구간별 상수(Stepwise constant) 형태로 구분하여 추정한다.

<Accordion activeIndex={[0]}>
<AccordionTab header="K-ICS 확률론 시나리오 모수 추정 구간 ">      
  <GImg caption = "" maxWidth="500px">
  ![aa](/esg/HW-param-Fiqure_1.png)
  </GImg>
  수렴속도 모수($\alpha$)와 변동성 모수($\sigma$)는 스왑션 데이터가 관찰되는 기간과 데이터가 관찰 되지 않는 기간으로 구분하여 다음의 기준에 따라 산출한다. 다만, 수렴속도 모수($\alpha$)의 최저한도는 0.0001로 한다.
      - ㈀ 모수 산출에 사용되는 스왑션 데이터는 시장에서 관찰되는 모든 스왑션 데이터(옵션만기 1년, 2년, 3년, 5년, 7년, 10년 및 스왑만기 1년, 2년, 3년, 5년, 7년, 10년에 해당하는 총 36개 데이터)를 사용한다.
      - ㈁ 스왑션 데이터가 관찰되는 기간의 수렴속도 모수($\alpha$)는 세부기간을 구분하지 않고 단일의 모수로 산출하며, 변동성 모수($\sigma$)는 0\~1년, 1\~2년, 2\~3년, 3\~5년, 5\~7년, 7\~10년 기간별로 세분화하여 모수를 산출한다.
      - ㈂스왑션 데이터가 관찰되지 않는 기간의 수렴속도 모수($\alpha$) 및 변동성 모수($\sigma$) 산출 기준은 감독원장이 제시한다.
      - ㈃ 수렴속도 모수($\alpha$) 및 변동성 모수($\sigma$)는Ⅱ.2-2.가 (무위험 금리기간구조)를 바탕으로 산출한다.
  </AccordionTab>
  </Accordion>

<TabView>
<TabPanel header="α(수렴속도)  ">
  회귀모수 $\alpha$ : 금리시나리오가 수익률 곡선에 회귀하는 속도를 결정하는 모수

  평균 회귀 계수(mean reversion coefficient) 금리가 평균 수준으로 회귀할 때 속도를 결정함. 알파가 클수록 평균수준에 빠르게 회귀. max (산출값, 0.0001)

  <GCallout severity="success" title ="수렴속도">
      - – 스왑션 데이터가 관찰되는 기간의 수렴속도 모수는 세부기간을 구분하지 않고 단일의 모수로 산출.
      - – 스왑션 데이터가 관찰되지 않는 기간의 수렴속도 모수 및 변동성 모수 산출 기준은 감독원장이 제시한다.
        - • 단기 (20년 이내)는 단일값
        - • 장기(20년 초과)는 장기구간 (10년\~20년)의 최근 10년 평균값 사용
  </GCallout>
  
</TabPanel>
<TabPanel header="σ(변동성) ">
  금리의 변동성을 결정하는 모수 , 확산 계수(diffusion coefficient)
    <GCallout severity="success" title ="변동성모수">
      - – 변동성 모수는 0\~1년, 1\~2년, 2\~3년, 3\~5년, 5\~7년, 7\~10년 기간별로 세분화하여 모수를 산출.
      - – 스왑션 데이터가 관찰되지 않는 기간의 수렴속도 모수 및 변동성 모수 산출 기준은 감독원장이 제시한다.
        - • 단기(10년 이내) : 구간별로 적용
        - • 장기(10년 초과) : 장기구간 (7년\~10년)의 최근 10년 평균값 사용
    </GCallout>
</TabPanel>
<TabPanel header="θ 장기평균 ">

  수익률곡선이 복원 가능하도록 조정하는 역할을 하는 함수, Yeild Curve Fitting, 관찰된 시장 금리곡선에 적합시켜 금리가 시장금리곡선을 중심으로 수렴하도록 함.

  <GCallout severity="success" title ="수익률 곡선 적합함수, 목표금리">  
  $$
    \theta(t) = \dfrac{f_{t+1}-f_t}{\alpha \Delta t} + f_t + \int_0^t \sigma_i^2 e^{-2\alpha(t-u)}du
  $$
  </GCallout>

</TabPanel>
</TabView>


## 4. Cailibration

  ```java filename="Hw1fCalibrationKics.java"
  public List<Hw1fCalibParas> getHw1fCalibrationResultList(String mode) {	
		applySmithWilsonInterpoloation(this.prjInterval, this.lastLiquidPoint);		
		calSwpnSwapRate();		
		calSwpnPriceAtm();		
		optParasHw();		
		List<Hw1fCalibParas> hw1fParam = new ArrayList<Hw1fCalibParas>();
		return hw1fParam;		
	}
  ```
<Card subTitle="input">
- – 만기 $T$, 잔존기간(스왑기간) $\tau$, 행사가격 $K$ 인 스왑션의 시장가격 $V^{mkt}$
- – 시장에서 관찰되는 이자율 커브 (zero curve) : $P(0,t)$
- – 해당 스왑션의 내재변동성 $\sigma_{Black}$
</Card> 


  <TabView>
  <TabPanel header="1.할인계수 산출 ">
  - – 스왑, 스왑션 가격 산출 시 필요한 할인계수 산출 
  - – 비유동구간까지 금리커브를 보간하여 전 구간에 대한 무위험 이자율 커브 생성
  ```java filename="applySmithWilsonInterpoloation(...)"
  //	1st Step 1-1: Preparation of Swap Cashflow from Smith-Wilson Result from baseCurve
	private void applySmithWilsonInterpoloation(int prjInterval, double lastLiquidPoint) {
		
		Map<Double, Double> ts = new TreeMap<Double, Double>();
		for(int i=0; i<this.tenor.length; i++) ts.put(this.tenor[i], this.iRateBase[i]);

		SmithWilsonKics sw = new SmithWilsonKics(this.baseDate, ts, this.cmpdType, this.isRealNumber, this.ltfr, this.ltfrT, (int) Math.round(lastLiquidPoint), prjInterval, 100, this.dayCountBasis);			
		this.swRsltList = sw.getSmithWilsonResultList();		

		this.pmtIdxBaseRate   = this.swRsltList.stream().map(s -> s.getMatTerm() * this.freq).mapToInt(Double::intValue).toArray();
		this.priceBaseRate    = this.swRsltList.stream().map(s -> s.getDcntFactor()).mapToDouble(Double::doubleValue).toArray();		
		this.spotContBaseRate = this.swRsltList.stream().map(s -> s.getSpotCont()).mapToDouble(Double::doubleValue).toArray();
		this.fwdContBaseRate  = this.swRsltList.stream().map(s -> s.getFwdCont()).mapToDouble(Double::doubleValue).toArray();		
	}	
  ```
  </TabPanel>
  <TabPanel header="2. 스왑레이트 산출">
  - – 각 ATM 스왑션에 해당하는 스왑레이트(현시점에서 고정과 변동의 현재가치를 같게 만드는 고정금리 수준) 계산 
  - – 스왑에서 고정금리는 고정이자 지급의 현재가치와 변동 이자와 원금의 현재가치를 같게 하는 금리로 정의됨. 
    - $PV_{fixed} = SwapRate \cdot \sum_{i=1}^{N} \Delta_k \cdot P(t_k)$ 이고 $PV_{floating} = P(t_a) - P(t_b)$ 이므로 두 값이 동일하게 하는 SwapRate
<GMath title ="Swap Rate">
  $$
  SwapRate = \frac{P(t_a) - P(t_b)}{\sum_{i=1}^{N} \Delta_k \cdot P(t_k)} 
  $$
</GMath>
<GCmt>
- • $t_a$ :(`this.swpnMat[i]`) 스왑 시작 시점 = 스왑션 만기 (스왑 개시시점) 
- • $t_b$ : (`this.swapMatTenor[i][j]`) 스왑 종료 시점 = 스왑션 만기 + 스왑 기간 
- • $P(t)$ : (`this.priceBaseRate[k]`) t시점에서의 할인계수 
- • $\Delta_k$ : (`this.freq`) 스왑의 각 현금흐름 발생 시점의 기간 (예: 6개월, 1년 등) ; 고정이자 지급주기 
</GCmt>
  ```java filename="calSwpnSwapRate()"
  //	1st Step 1-2: Calculate Exercise Rate of Swaption and PV of Swap Cashflow
	private void calSwpnSwapRate() {
		
		this.swapRate      = new double[this.swpnMat.length][this.swapTenor.length];
		this.swapDfSum     = new double[this.swpnMat.length][this.swapTenor.length];		
				
		for(int i=0; i<this.swpnMat.length; i++) {
			for(int j=0; j<this.swapTenor.length; j++) {
				this.swapDfSum[i][j] = 0.0;		
				
				for(int k=0; k<pmtIdxBaseRate.length; k++) {								
					if((k+1) > this.swpnMat[i] * this.freq && (k+1) <= this.swapMatTenor[i][j] * this.freq) {
						this.swapDfSum[i][j] = this.swapDfSum[i][j] + this.priceBaseRate[k]; 
					}
				}
				this.swapRate[i][j] = (this.priceBaseRate[this.swpnMat[i]* this.freq - 1] - this.priceBaseRate[this.swapMatTenor[i][j] * this.freq - 1]) / (this.swapDfSum[i][j] / this.freq);				
			}				
		}
	}
  ```
  </TabPanel>
  <TabPanel header="3. 스왑션 시장가격 산출 ">
  - – 스왑션(일정 시점(T)에 고정금리를 지급하고 변동금리를 받는 이자율 스왑을 체결할 수 있는 권리)의 ATM(스왑레이트가 행사가격 K와 동일한 스왑션) 가격 계산 
  - – 최적화 대상이 되는 스왑션 가격을 설정해야 Hull-White 모형의 파라미터를 추정할 수 있음

  <GMath title ="Black 모델에서 스왑션 가격">
  $$
  Price_{ATM} = N(d_1) \cdot P(0,T) \cdot K - N(d_2) \cdot P(0,T) \cdot K
  $$
  </GMath>

    ```java filename="calSwpnPriceAtm()"
    //	1st Step 1-3: Calculate At The Money Price of of Swaption	 
      private void calSwpnPriceAtm() {
        
        this.swpnPriceAtm = new double[this.swpnMat.length][this.swapTenor.length];
        
        for(int i=0; i<this.swpnMat.length; i++) {
          for(int j=0; j<this.swapTenor.length; j++) {
            
            double T    = this.swpnMat[i];
            double dPos = ( Math.log(this.swapRate[i][j]/this.swapRate[i][j]) + 0.5 * Math.pow(this.swpnVolMkt[i][j], 2) ) * T / (this.swpnVolMkt[i][j] * Math.sqrt(T));
            double dNeg = dPos - (this.swpnVolMkt[i][j] * Math.sqrt(T));
            
            this.swpnPriceAtm[i][j] = this.notional * (this.swapDfSum[i][j] / this.freq) 
                                                * (  this.swapRate[i][j] * new NormalDistribution().cumulativeProbability(dPos)
                                                  - this.swapRate[i][j] * new NormalDistribution().cumulativeProbability(dNeg) );    // for payer swaption				
            if(Math.abs(this.swpnPriceAtm[i][j]) < ZERO_DOUBLE) this.swpnPriceAtm[i][j] = 0.1;
          }		
        }
      }
    ```  

    ```java
          double T = this.swpnMat[i]; // 스왑션 만기
          double sigma = this.swpnVolMkt[i][j]; // 내재변동성
          double K = this.swapRate[i][j];       // 스왑레이트 = 행사가격
          double A = this.swapDfSum[i][j] / this.freq; // Annuity = 고정지급의 현재가치

          double dPos = (Math.log(K / K) + 0.5 * sigma^2) * T / (sigma * sqrt(T)); // = 0.5 * sigma * sqrt(T)
          double dNeg = dPos - sigma * sqrt(T);                                    // = -0.5 * sigma * sqrt(T)

          this.swpnPriceAtm[i][j] = this.notional * A * (K * N(dPos) - K * N(dNeg)); // Black 수식
          ```
  </TabPanel>
  <TabPanel header="4. 모수 최적화 ">
    - – $\alpha$, $\sigma$ 모수 최적화
    - – 이론가격이 시장가격과 가장 유사하도록 파라미터 추정

   <Accordion activeIndex={[0]}>
   <AccordionTab header="optParasHw() ">
      ```java filename="optParasHw()"
          protected void optParasHw() {
            optParasHw(new int[] {0, 1, 2, 3, 4, 5}, new int[] {0, 1, 2, 3, 4, 5});
          }	
      ```
      ```java
          private void optParasHw(int[] swpnMatIdx, int[] swapTenorIdx) {		
            this.optParas = calibOptim(swpnMatIdx, swapTenorIdx, this.initParas);
          }
      ```
        
   </AccordionTab>
   <AccordionTab header="calibOptim(...) ">
      ```java
          protected double[] calibOptim(int[] swpnMatIdx, int[] swapTenorIdx, double[] paras) {

        MultivariateFunction fp = new MultivariateFunction() {
          public double value(double[] paras) {
            return calibErrFn(swpnMatIdx, swapTenorIdx, paras);
          }
        };
        
        double[] fpLower = new double[paras.length];
        double[] fpUpper = new double[paras.length];
        double[] fpScale = new double[paras.length];
        
        for(int i=0; i<paras.length; i++) {
          fpLower[i] = (i<=1) ? this.alphaMin : this.sigmaMin;
          fpUpper[i] = (i<=1) ? 2e-1 : 2e-2;
          fpScale[i] = 1000;
        }		
          MultivariateFunctionPenaltyAdapter fpConstr = new MultivariateFunctionPenaltyAdapter(fp, fpLower, fpUpper, 1000, fpScale);
        
        double[] calibParas = paras;
        double   calibValue = 0.0;		
        
        log.info("{}, {}, {}", LocalDateTime.now(), this.accuracy, paras);		
        try {			
          for(int i=0; i<this.itrMax; i++) {		
            
            SimplexOptimizer optimizer = new SimplexOptimizer(1e-12, 1e-12);
            AbstractSimplex  ndsimplex = new NelderMeadSimplex(nelderMeadStep(calibParas, 0.001));
            PointValuePair   result    = optimizer.optimize(new MaxEval(100000)
                                                      , new ObjectiveFunction(fpConstr)
                                                      , ndsimplex
                                                      , GoalType.MINIMIZE
                                                      , new InitialGuess(calibParas));				
            
            log.info("{}, {}, {}, {}", i, result.getValue(), LocalDateTime.now(), result.getPoint());		
            calibParas = result.getPoint();
            this.costValue = result.getValue();
            
            if(Math.abs(result.getValue() - calibValue) < this.accuracy) break;	
            calibValue = result.getValue();
            
          }
        }
        catch (Exception e) {
          log.error("Error in Cailibration of Hull-White 1 Factor Model Parameters [Calibration Mode = KICS]");
          e.printStackTrace();
        }		
        log.info("{}, {}", LocalDateTime.now(), calibParas);		
      
        return calibParas;
      }
    ```  
        
   </AccordionTab>
   <AccordionTab header="calibErrFn(...) ">
      err = 관측된 스왑션 가격(swpnPriceAtm)과 모델로 계산한 스왑션 가격(swpnPriceHw)의 상대 제곱 오차의 합

      ```java
      private double calibErrFn(int[] swpnMatIdx, int[] swapTenorIdx, double[] paras) {
          
          double[][] swpnPrcHw = new double[swpnMatIdx.length][swapTenorIdx.length];
          double err = 0.0;
          double t1  = 0.0;
          double t2  = 0.0;
          int    k   = 0;     
          int    l   = 0;
          
          double[] alpha = new double[] {paras[0], paras[1]};
          double[] sigma = new double[] {paras[2], paras[3], paras[4], paras[5], paras[6], paras[7]};

          for(int i=0; i<swpnMatIdx.length; i++) {
            for(int j=0; j<swapTenorIdx.length; j++) {
              k  = swpnMatIdx[i];
              l  = swapTenorIdx[j];
              t1 = swpnMat[k];
              t2 = swapMatTenor[k][l];				
            
              swpnPrcHw[i][j] =  swpnPriceHw(t1, t2, alpha, sigma, this.swapRate[k][l]);
                      err += Math.pow( (this.swpnPriceAtm[k][l] - swpnPrcHw[i][j]) / this.swpnPriceAtm[k][l], 2);                 
            }
          }
          return err;
        }	
      ```
   </AccordionTab>
   <AccordionTab header="swpnPriceHw() ">
   Jamshidian 아이디어를 활용해서 rOptim을 먼저 산출하고, 이를 사용하여 스왑션 가격을 계산한다.
        ```java
          private double swpnPriceHw(double t1, double t2, double[] alpha, double[] sigma, double K) {
            
            double dt     = 1.0 / this.freq;
            double rOptim = 0.0;
            
            UnivariateFunction fp = new UnivariateFunction() {
              public double value(double sRate) {
                return rOptimSwpnErrFn(t1, t2, alpha, sigma, dt, K, sRate);
              }
            };
              
            UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);
            rOptim = optimizer.optimize(new MaxEval(10000)
                                  , new UnivariateObjectiveFunction(fp)
                                  , GoalType.MINIMIZE
                                  , new SearchInterval(-0.9, 1.0)).getPoint();
            
            double[] swpnDt      = swpnDt(t1, t2, dt);
            double[] swpnCf      = swpnCf(t1, t2, dt, K);		
            double[] swpnSigma   = swpnSigma(t1, t2, alpha, sigma, dt);
            double   swpnPriceHw = 0.0;        

            for(int i=0; i<swpnDt.length; i++) {
                  
                  double xZbc  = hwZcbPrice(t1, swpnDt[i], alpha, sigma, rOptim);
                  double pt0   = hwZcbPrice( 0,        t1, alpha, sigma, this.fwdContBaseRate[0]);
                  double pti   = hwZcbPrice( 0, swpnDt[i], alpha, sigma, this.fwdContBaseRate[0]);
                  double dPos  = Math.log(pti / xZbc / pt0) / swpnSigma[i] + 0.5 * swpnSigma[i];
                  double dNeg  = dPos - swpnSigma[i];
                  swpnPriceHw += this.notional * swpnCf[i] * (pti * new NormalDistribution().cumulativeProbability(dPos) - xZbc * pt0 * new NormalDistribution().cumulativeProbability(dNeg));
                }        
                return swpnPriceHw;
          }
        ```
   </AccordionTab>
   </Accordion> 


  </TabPanel>
  </TabView>
  
<Steps>
### 스왑션 변동성 

스왑션이란 금리 스왑에 대한 옵션으로, 특정 만기일에 금리 스왑을 체결할 수 있는 권리를 의미한다.
스왑션 가격은 기초자산인 금리의 미래 분포에 대한 기대값으로 결정된다. 즉 스왑션 가격은 미래 금리 경로의 확률적 특성을 반영하고 있다. 따라서 스왑션 가격은 금리의 평균수준, 변동성, 평균회귀속성 등에 따라 결정된다. 

스왑션 가격을 추정하는 모수는 결국 시장이 현재 기대하고 있는 금리의 움직임 (확률분포)을 잘 설명하는 값으로 해석할 수 있다. 
따라서 시장에서 관찰되는 만기별 스왑션 변동성(Implied Volatility)을 통해 금리모형의 모수를 추정할 수 있다.




### 이론 스왑션 가격 산출 (Jamshidian 방식)

    - 각 채권 옵션을 제로쿠폰에 대한 콜/풋 옵션의 합으로 분해하여 계산.

    <GCallout severity="warn" title ="Jamshidian 방식 idea">
    *__one-factor 이자율 모형 (Hull-White) 하에서 스왑션의 가치는, 스왑 만기 시점의 임계 단기 이자율 $r^*$을 기준으로 각 고정금리 현금흐름에 대한 zcb 옵션들의 가치 합과 같다.__*
    </GCallout>
    
    - 즉, 만기시점에 채권의 가치가 행사가격을 초과하는지 여부에 따라 모든 현금흐름이 동시에 행사되거나 행사되지 않음을 이용함. 

    <Accordion activeIndex={[0]}>
    <AccordionTab header="1. 스왑션의 만기 및 행사 조건 정의">
        - – 스왑션 만기(Expiry): $T_E$
        - – 기초 스왑 시작일: $T_{S1}$ 
        - – 기초 스왑 종료일: $T_{SN}$ 
        - – 스왑 행사가격(Fixed Rate): $K$
        - – 명목 원금(Notional): $N$ (보통 1)
          
    </AccordionTab>
    <AccordionTab header="2. 고정금리 레그 현금 흐름 정의">
        스왑의 고정금리 레그는 $T_{S1}$부터 $T_{SN}$까지 주기적으로 발생하는 $N⋅K⋅기간계수$ 형태의 쿠폰 현금 흐름과 마지막 원금 상환($N$)으로 구성됨. 이 현금 흐름들은 각각 미래 특정 시점 $t_i$ 에 지급됨.
          
    </AccordionTab>
    <AccordionTab header="3. r* (rOptim)찾기 ">
        스왑 만기($T_E$)시점에 스왑의 고정금리 레그의 가치를 행사가격 $K$에 해당하는 가치와 같게 만드는 이자율 $r^*$ 를 찾기. 임계(critical) 이자율 $r^*$
        - – $T_E$시점의 이자율 < $r^*$ : 이익, 옵션 행사 
        - – $T_E$시점의이자율 > $r^*$ : 손해, 옵션 미행사 
        - – $r^*$는 스왑 만기 시점의 이자율 $r(T_E)$의 특정 값.
        - – $r^*$를 찾기 : $T_E$ 시점에서 스왑의 고정금리 레그 현금 흐름을 $r^*$를 사용하여 할인했을 때, 그 총 가치가 0이 되거나 특정 행사가치를 만족하는 $r^*$를 찾는 수치적인 방법(예: 이분법, 뉴턴-랩슨법)이 필요함. 
          
    </AccordionTab>
    <AccordionTab header="4. 각 현금 흐름을 Zero Coupon Bond에 대한 옵션으로 변환">
        $r^*$를 알면, 스왑션 만기 $T_E$ 시점에 각 현금 흐름 $C_i$가 행사가격 $P(T_E,t_i,r^*)$를 가지는 Zero Coupon Bond $P(T_E,t_i)$에 대한 콜 옵션으로 쉽게 스왑션 가치를 산출 가능. 
        - – $P(T_E,t_i,r^*)$ : $T_E$ 시점의 단기 이자율 = $r^*$일 때 만기 $t_i$인 Zero Coupon Bond의 가치.
        - – 모든 현금 흐름 $C_i$ : $T_E$ 시점의 단기 이자율 $r(T_E)$ < $r^*$ 일 때 (콜 옵션의 경우) 동시에 '행사'되는 것으로 간주됨. (풋 옵션은 $r(T_E)$ > $r^*$일 때) 
          
    </AccordionTab>
    <AccordionTab header="5. 각 Zero Coupon Bond 옵션의 가격을 블랙 모형으로 산출">
        - – 각 현금 흐름 $C_i$에 대해, $T_E$ 만기, 행사가격 $P(T_E,t,r^*)$인 Zero Coupon Bond 옵션의 가격을 계산.
        - – 이때, 블랙(Black) 모형의 채권 옵션 가격 결정 공식을 활용.
        <GMath title ="블랙-숄즈 채권 옵션가격공식">
        $$
        V_{model}(\alpha, \sigma) = \sum_{i=1}^N P(0,t_i) \times Forword Bond Price \times N(d_1)- P(0,T_E)\times K \times N(d_2)
        $$
        </GMath>
        <GCmt>
        - – $P(0,t_i)$: 현재시점 (0)에서 만기 $t_i$인 Zero Coupon Bond의 가격(할인율)
        - – Forword Bond Price$_i$ : $T_E$시점의 단기 이자율이 $r^*$일 때 만기 $t_i$인 Zero Coupon Bond의 기대 포워드가격.
        - – $K$ : $T_E$시점의 단기 이자율이 $r^*$일 때 만기 $t_i$인 Zero Coupon Bond의 행사가격 (즉, $P(T_E,t_i,r^*)$).
        - – $N(d_1)$,$N(d_2)$: 표준 정규 분포 누적 함수. $d_1$,$d_2$ 는 블랙 모형의 변수들로, 기초자산의 변동성($\sigma_{Black}$), 만기, 금리 등에 의해 결정됨. 
        - – $\sigma_{Black}$: $\sigma_{Black}$​은 채권 가격의 변동성. 이 변동성은 Hull-White 모형의 $\alpha$와 $\sigma(t)$로부터 유도(즉, Hull-White 모형으로 채권 가격 변동성을 계산하여 블랙 모형에 입력)        
        </GCmt>
          
    </AccordionTab>
    <AccordionTab header="6. 모든 개별 채권 옵션 가격의 합">
      위에서 계산된 각 현금 흐름에 대한 채권 옵션 가격을 모두 합산하면 스왑션의 이론적인 가격이 됨.
    </AccordionTab>
    </Accordion>


   


### 목적함수 설정 (최소제곱법)

관측된 스왑션 가격(swpnPriceAtm)과 모델로 계산한 스왑션 가격(swpnPriceHw)의 상대 제곱 오차의 합을 최소화하는 모수 세트를 추정함. 
```java
err += Math.pow( (this.swpnPriceAtm[k][l] - swpnPrcHw[i][j]) / this.swpnPriceAtm[k][l], 2); 
```

<Accordion activeIndex={[0]}>
<AccordionTab header="계단식상수로 정의된 모수를 이용해서 theta 구하기 ">
      
* $\alpha$는 단기구간(20년 미만)과 장기구간(20년 이후)으로 구분된 piecewise constant.

    $$
    \alpha(t) = \begin{cases}    \alpha_1 &\text{if } t \lt \tau \\    \alpha_2 &\text{if } t \ge \tau  \end{cases}
    $$

* $\sigma$는 스왑션 만기구간(1,2,3,5,7,10,이후)에 따라 구분된 piecewise constant.

    $$
    \sigma(t) = \begin{cases}   \sigma_1 &\text{if } t_0 \le t \lt t_1 \\    \sigma_2 &\text{if } t_1 \le t \lt t_2 \\ \\ \cdots \\ \\ \sigma_{M-1} &\text{if } t_{M-2} \le t \lt t_{M-1} \\    \sigma_M &\text{if } t_{M-1} \le t   \end{cases}
    $$

위의 구간별 상수로 주어진 모수함수를 이용해 수치적분

* $$A(t,T) = e^{- \int_t^u \alpha(v)dv}$$
* $$B(t,T) = \displaystyle\int_t^T e^{-\int_t^u\alpha(v)dv}du$$
* $$Z(t)= \displaystyle \int_0^t \sigma(u)^2 \cdot e^{-\int_u^t \alpha(v)dv} \cdot B(u,t)du$$
* $$\xi(t) = \displaystyle \int_0^t \sigma(u)^2 \cdot e^{-2\int_u^t\alpha(v)dv}du$$
*   $$\Omega(t,T) = \displaystyle\int_0^t \sigma(u)^2 \{ B(u,t)^2 - B(u,T)^2 \}du$$

구간 $t$가 어디에 있는지에 따라 $a(t)$와 $\sigma(t)$가 다르게 정의되므로, $A(t,T)$, $B(t,T)$, $Z(t,T)$는 다음과 같이 정의된다.
<GMath title ="">
$$
A(t,T) = \begin{cases} e^{-\alpha_1(T-t)}  &\text{if } T \lt \tau \\    e^{-\alpha_2(T-t)} &\text{if } t \ge \tau \\ e^{-\alpha_1(\tau-t)-\alpha_2(T-\tau)} &\text{if } t \le \tau  \le T \end{cases}
$$
</GMath>

<GMath title ="">
$$
B(t,T) = \begin{cases}  \dfrac {1-e^{-\alpha_1(T-t)}}{\alpha_1}   &\text{if } T \lt \tau \\ \\  \dfrac {1-e^{-\alpha_2(T-t)}}{\alpha_2} &\text{if } t \ge \tau \\ \\  e^{-\alpha_1(\tau -t)} \cdot \dfrac {1-e^{-\alpha_2(T-\tau)}}{\alpha_2}  &\text{if } t \le \tau  \le T  \end{cases}
$$
</GMath>

<GMath title ="">
$$
Z(t,T) = \begin{cases}   \displaystyle \int_0^t \sigma(u)^2 \cdot e^{-\alpha_1(t-u)}\cdot  \dfrac {1-e^{-\alpha_1(T-t)}}{\alpha_1} du    &\text{if } t \lt \tau \\  \\    e^{-\alpha_2(t-\tau)} \cdot  \displaystyle \int_0^ \tau \sigma(u)^2 \cdot e^{-\alpha_1(\tau-u)}\cdot  \{\dfrac {1-e^{-\alpha_1(\tau-u)}}{\alpha_1}\}du \\ + e^{-\alpha_2(t-\tau)}  \displaystyle \int_0^ \tau \sigma(u)^2 \cdot e^{-\alpha_1(\tau-u)}\cdot  \{\dfrac {1-e^{-\alpha_2(t-\tau)}}{\alpha_2}du\} \\ + \displaystyle \int_\tau^ t \sigma(u)^2 \cdot e^{-\alpha_2(t-\tau)}\cdot \{\dfrac {1-e^{-\alpha_2(t-u)}}{\alpha_2}\}du   &\text{if } t \ge \tau   \end{cases}
$$
</GMath>


[참고 site](https://www.r-bloggers.com/2021/06/hull-white-1-factor-model-using-r-code/)

</AccordionTab>
</Accordion>

<Accordion activeIndex={[0]}>
<AccordionTab header=" parameter Calibration">

    * 변동성으로 금리 Receiver 스왑션의 Black Vol을 이용함. (즉, 스왑션 만기시 해당 Tenor기간동안 변동금리를 지급하고 정해진 스왑금리로 고정금리를 수취하는 스왑계약을 체결할 수 있는 권리)
      * 금리스왑션가격은 금액이 아닌 블랙모형을 이용한 ATM 내재변동성 (Black Vol)으로 고시. (ATM 내재변동성이란 스왑션 만기에 시작되고 그 만기(t)가 스왑션의 tenor($$\tau$$)가 되는 forward start 스왑의 금리를 행사가로 하는 스왑션의 내재변동성을 의미함. )
      * Black Model 을 이용하여 스왑션을 평가하기 위해 스왑션변동성이 필요함. (시장에서 관찰되는 스왑션의 잔존만기 및 대상 스왑의 테너에 따라 ATM 스왑션의 변동성을 사용.  스왑션의 잔존만기와 스왑의 테너를 각각의 축으로 가지는 2차원 Grid Point에 해당하는 스왑션 변동성을 시장에서 호가되는 자료로 사용함. )
    * Black Vol을 이용하여 스왑션 가격을 산출함.
      * Black Model을 이용하여 스왑션 만기(6개)별 스왑테너별로 총 48개의 스왑션 가격을 산출.
      * receiverSwaption = $$N \cdot A[K\cdot N(-d_2)-Swap(t-\tau) N(-d_1)]$$
        * $$A = \sum_i P(0,t_i)$$
        * $$d_1= \dfrac{ln(\frac{Swap(t,\tau)}{K} +\frac{1}{2}\sigma^2 T)}{\sigma\sqrt{T}}$$
        * $$d_2 = d_1 -\sigma \sqrt{T}$$
        * $$t_i$$: 스왑의 이자 교환일, $$N$$은 액면가
      
</AccordionTab>
</Accordion>

</Steps>

## 4. 시나리오 산출

* 단기금리(Short Rate)가 다음의 프로세스를 따른다고 가정.$$dr(t) = \alpha \cdot [ \theta(t) - r(t)]dt + \sigma \cdot dW_t$$ 
* 위의 식을 이산화하면 다음과 같음. $$r_{t+1} = r_t + \alpha (\theta(t_i, t_{i+1})-r_t)\cdot \Delta t_i + \sigma_i(t) \sqrt{\Delta t_i } \cdot \epsilon_t$$
  * 난수 $$\epsilon \thicksim N(0,1)$$를 추출하여 Calibration에 의해 산출된 모수를 적용하여 단기금리 시나리오를 산출.


## 5. 적정성 검증

아래 내용이 포함된 시나리오 유효성 검증 보고서를 위험리위원회에 보고해야 함.

<TabView>
<TabPanel header="모수 적정성 ">
  
  * 모수 추정 방법의 유효성 : 모수는 최적해를 효율적으로 찾을 수 있는 알고리즙에 기반하여 산출
  * 시장가격 설명력 : 추정된 모수를 통해 산출한 모형가격과 시장가격의 차이가 최소화
  * 모수 추정결과의 안정성 : 시장데이터 일부를 변경하여 모수를 추정하더라도 모수가 안정적로 산출되어야 함.
  * 스왑션 데이터의 일관성 및 적합성 : 블랙 변동성과 노말 변동성 중 금리 환경 및 시나리오 추정 등에 적합한 데이터 사용

</TabPanel>
<TabPanel header="난수 적정성 ">
  
  * 시나리오 간 정규성 : 난수의 분포는 매 경과기간마다 정규성 만족 
  * 경과기간별 독립성 :  난수는 경과기간별로 독립 
  * 난수 고정 사용 :
    * 최소 10개 이상의 난수 집합을 생성한 후, 그 중 결과적정성이 가장 우월한(확률론 금리 시나리오 평균과 수익률 곡선의 편차가 가장 작은 난수 집합) 난수를 선정하고,
    * 매 평가시점마다 동일하게 적용.
    * 결과 적정성 검증 기준을 충족하지 못하는 경우에만 난수 변경 가능.

</TabPanel>
<TabPanel header="결과 적정성 ">
  
  * 확률론적 금리 시나리오의 평균이 수익률 곡선과 통계적으로 일치
  * 마팅게일 테스트
    * 미래 현금흐름의 현가가 정규분포를 따른다는 가정 하에
    * 시나리오별 무이표채 현가의 평균과
    * 수익률 곡선(결정론적 금리시나리오)의 무이표채 현가와 95% 신뢰수준하에서 일치
  * $$\mu$$ 가 95% 신뢰구간 $$(\bar X-1.96SE, \bar X +1.96SE)$$에 위치하면 시장 일관성이 성립한다고 판단
    * $$\mu$$ : 수익률 곡선의 무이표채 현가
    * $$\bar X$$: 시나리오 할인 곡선의 무이표채 현가의 평균
    * $$SE$$ : 시나리오 할인 곡선의 무이표채 현가의 표준오차

</TabPanel>
</TabView>

